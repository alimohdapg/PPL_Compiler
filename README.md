# PPL_Compiler
A compiler for a custom procedural programming language that targets RISC-V assembly code.

## Contents
[File Structure & Running The Compiler](https://github.com/alimohdapg/PPL_Compiler/new/master?readme=1#file-structure--running-the-compiler)

[Language & Execution Model](https://github.com/alimohdapg/PPL_Compiler/new/master?readme=1#language--execution-model)

[Language Syntax](https://github.com/alimohdapg/PPL_Compiler/new/master?readme=1#language-syntax)

[Simple Example Programs](https://github.com/alimohdapg/PPL_Compiler/new/master?readme=1#simple-example-programs)
- [Macros added to the generated RISC-V assembley code](https://github.com/alimohdapg/PPL_Compiler/new/master?readme=1#macros-added-to-the-generated-risc-v-assembley-code)
- [Example Program #1](https://github.com/alimohdapg/PPL_Compiler/new/master?readme=1#1)
- [Example Program #2](https://github.com/alimohdapg/PPL_Compiler/new/master?readme=1#2)
- [Example Program #3](https://github.com/alimohdapg/PPL_Compiler/new/master?readme=1#3)
- [Example Program #4](https://github.com/alimohdapg/PPL_Compiler/new/master?readme=1#4)

## File Structure & Running The Compiler
The compiler is split into 3 separate parts/tasks, task1 is responsible for turning a syntactically valid program into an s-expression. task2 is then used to check if the generated s-expression is semantically valid, and if so either returns the same s-expression or a new one with the main function as the first function declaration. task3 then turns the s-expression returned by task2 into a RISC-V assembly language program.

For task1, the src directory acts as the sources root directory directly, tasks 2 and 3 have two sub-directories within their src directory, main and test, acting as the sources root and test sources root directories respectively.

Outside the language directory within each task, the .g4 file stores the lexer and parser rules passed to ANTLR to generate lexers and parsers. Within the language directory, the following files are automatically generated by ANTLR (X is a placeholder):
- X.interp, X.tokens, XBaseListener.java, XBaseVisitor.java, XLexer.java, XLexer.interp, XLexer.tokens, XListener.java, XParser.java, XVisitor.java

In task1, Worker.java is used to recursively traverse a given parse tree and construct an ArrayList of ArrayLists and Strings. The ArrayList represents the s-expression form of the given program. When task1 is run, it gets input in the form of a syntactically valid program from System.in. It then returns the s-expression associated with the given program.

Similar to task1's Worker.java file, task2's SExpressionsAnalyser.java also recursively traverses a parse tree, this time of an s-expression. It reports back any errors present within the s-expression, highlights them, and states their cause. If no errors are present, it returns the same passed s-expression with the main function as the first function declaration. task2.java also takes input from System.in, passes the input as a parse tree to SExpressionSAnalyser.java, and prints out what it receives.

Task3's Worker.java file is also used to recursively traverse a parse tree of an s-expression, whilst doing so, it also constructs RISC-V assembly code in the form of a stack machine. The output can then be retrieved through the method getOutput() which returns the constructed assembly code along with some predefined macros for comparison, arithmetic, and boolean operations. task3.java takes input from System.in and provided that the input is a semantically valid s-expression, returns the corresponding runnable RISC-V assembly code obtained from Worker.java.

RARSInterface.java assembles and simulates the execution of RISC-V assembly code. It can be used to validate the assembly code obtained from task3.java.

Test files are available under task2/src/test and task3/src/test.

Note: All input through System.in must end with CTRL + D (shown as ^D inside the terminal).

## Language & Execution Model
In this procedural programming language, functions may be declared in the top-level scope, in any order, and can invoke functions that are defined earlier or later in the source file. All arguments to functions are passed by value, and the only identifiers which are defined in any function scope, are the names of other functions (which may be defined earlier or later) and the parameters taken by the current function. No variables can be declared apart from the parameters of the current function. Function parameters must either be of type int or bool. Functions must have distinct names.

The output of a function is the value of the code-block given by its function body; which is to say, the value of the final expression in the function body.

The main program is described by a function with name and signature int main(), which may occur anywhere in the function declarations. This function may perform a simple computation with constants, or call another function on some constants, to evaluate some integer value.

## Language Syntax
- Keywords:
  - if , then , else , skip , while , do , repeat , until , int , bool , and unit. 
  - Note that keywords are case sensitive, and do not contain upper-case letters.
- Integers:
  - Integers are unsigned integers, consisting either of a 0, or a non-empty string of digits 0–9 which does not begin with 0.
- Identifiers:
  - Identifiers are strings consisting of letters (lower or upper case), digits, and the underscore character, apart from those which match a keyword as above. 
  - Identifiers must begin with a lower-case alphabetic character.
- Operators and delimiters:
  - The special syntactic symbols (e.g., parentheses, assignment operator, etc.) consist of the following one- or two-character symbols:
    - ;  (  )  ==  <  >  <=  >=  ,  {  }  :=  +  *  -  /  &&  ||  ^^
- White space:
  - White space is not a part of any token, and consists of any sequence of the characters
    - ⎵ (blank, ascii 32) ;  
    - \n (newline, ascii 10) ;  
    - \r (carriage return, ascii 13) ;  
    - \t (tab, ascii 9) .

## Simple Example Programs
### Macros added to the generated RISC-V assembly code:
```
.macro CompEq()
 lw                  t1, 4(sp)
 addi         sp, sp, 4
 mv                  t3, t2
 beq                 t1, a0, true
 false:
     li                  t2, 0
     b                   exit
 true:
     li                  t2, 1
 exit:
.end_macro

.macro CompLt()
 lw                  t1, 4(sp)
 addi         sp, sp, 4
 mv                  t3, t2
 blt                 t1, a0, true
 false:
     li                  t2, 0
     b                   exit
 true:
     li                  t2, 1
 exit:
.end_macro

.macro CompGt()
 lw                  t1, 4(sp)
 addi         sp, sp, 4
 mv                  t3, t2
 bgt                 t1, a0, true
 false:
     li                  t2, 0
     b                   exit
 true:
     li                  t2, 1
 exit:
.end_macro

.macro CompLe()
 lw                  t1, 4(sp)
 addi         sp, sp, 4
 mv                  t3, t2
 ble                 t1, a0, true
 false:
     li                  t2, 0
     b                   exit
 true:
     li                  t2, 1
 exit:
.end_macro

.macro CompGe()
 lw                  t1, 4(sp)
 addi         sp, sp, 4
 mv                  t3, t2
 bge                 t1, a0, true
 false:
     li                  t2, 0
     b                   exit
 true:
     li                  t2, 1
 exit:
.end_macro

.macro Plus()
 lw                  t1, 4(sp)
 add                 a0, t1, a0
 addi         sp, sp, 4
.end_macro

.macro Minus()
 lw                  t1, 4(sp)
 sub                 a0, t1, a0
 addi         sp, sp, 4
.end_macro

.macro Times()
 lw                  t1, 4(sp)
 mul                 a0, t1, a0
 addi         sp, sp, 4
.end_macro

.macro Divide()
 lw                  t1, 4(sp)
 div                 a0, t1, a0
 addi         sp, sp, 4
.end_macro

.macro BoolAnd()
 addi         sp, sp, 4
 li                  t1, 1
 bne                 t2, t1, false
 bne                 t3, t1, false
 b                   true
 false:
     li                  t2, 0
     b                   exit
 true:
     li                  t2, 1
 exit:
.end_macro

.macro BoolOr()
 addi         sp, sp, 4
 li                  t1, 1
 beq                 t2, t1, true
 beq                 t3, t1, true
 false:
     li                  t2, 0
     b                   exit
 true:
     li                  t2, 1
 exit:
.end_macro

.macro BoolXor()
 addi         sp, sp, 4
 bne                 t2, t3, true
 false:
     li                  t2, 0
     b                   exit
 true:
     li                  t2, 1
 exit:
.end_macro

.macro FinalExit()
 li                  a7, 10
 ecall
.end_macro
```
### 1. 
```
int fun(int x, int y, int z) {
    if (x == y) then { z } else { 0 } }

int main() { fun(1, 2, 3) }
```
S-Expression Equivalent (Post Semantic Analysis):
```
[
  [FunDecl,
    Idfr("main"),
    IntType,
    [],
    [
      [FunInvoc,
        Idfr("fun"),
        [IntLit(1),
          IntLit(2),
          IntLit(3)]
      ]
    ]
  ],
  [FunDecl,
    Idfr("fun"),
    IntType,
    [
      [Idfr("x"), IntType],
      [Idfr("y"), IntType],
      [Idfr("z"), IntType]
    ],
    [
      [IfStmt,
        [BinOpExpr,
          Eq,
          Idfr("x"),
          Idfr("y")],
        [Idfr("z")],
        [IntLit(0)]
      ]
    ]
  ]
]               
```
Generated RISC-V Assembly Code:
```
.text

mainEnter:
	mv                  fp, sp
	sw                  ra, 0(sp)
	addi        sp, sp, -4
	sw                  fp, 0(sp)
	addi        sp, sp, -4
	li                  a0, 3
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	li                  a0, 2
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	li                  a0, 1
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	jal                 funEnter
	FinalExit()
funEnter:
	mv                  fp, sp
	sw                  ra, 0(sp)
	addi        sp, sp, -4
	lw                  a0,4(fp)
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	lw                  a0,8(fp)
	CompEq()
	bne                 t2, x0, label1
label2:
	li                  a0, 0
	b                   label3
label1:
	lw                  a0,12(fp)
label3:
	lw                  ra, 4(sp)
	addi        sp, sp, 20
	lw                  fp, 0(sp)
	jr                  ra
```
Execution Result:
```
NORMAL_TERMINATION
0
```
### 2. 
```
int main() { fibo(10) }

int fibo(int n) {
  if (n < 2)
  then { n } 
  else { (fibo((n - 1)) + fibo((n - 2))) } }
```
S-Expression Equivalent (Post Semantic Analysis):
```
[
  [FunDecl,
    Idfr("main"),
    IntType,
    [],
    [
      [FunInvoc,
        Idfr("fibo"),
        [IntLit(10)]
      ]
    ]
  ],
  [FunDecl,
    Idfr("fibo"),
    IntType,
    [
      [Idfr("n"), IntType]
    ],
    [
      [IfStmt,
        [BinOpExpr,
          Less,
          Idfr("n"),
          IntLit(2)],
        [Idfr("n")],
        [
          [BinOpExpr,
            Plus,
            [FunInvoc,
              Idfr("fibo"),
              [
                [BinOpExpr,
                  Minus,
                  Idfr("n"),
                  IntLit(1)]
              ]
            ],
            [FunInvoc,
              Idfr("fibo"),
              [
                [BinOpExpr,
                  Minus,
                  Idfr("n"),
                  IntLit(2)]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
]               
```
Generated RISC-V Assembly Code:
```
.text

mainEnter:
	mv                  fp, sp
	sw                  ra, 0(sp)
	addi        sp, sp, -4
	sw                  fp, 0(sp)
	addi        sp, sp, -4
	li                  a0, 10
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	jal                 fiboEnter
	FinalExit()
fiboEnter:
	mv                  fp, sp
	sw                  ra, 0(sp)
	addi        sp, sp, -4
	lw                  a0,4(fp)
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	li                  a0, 2
	CompLt()
	bne                 t2, x0, label1
label2:
	sw                  fp, 0(sp)
	addi        sp, sp, -4
	lw                  a0,4(fp)
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	li                  a0, 1
	Minus()
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	jal                 fiboEnter
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	sw                  fp, 0(sp)
	addi        sp, sp, -4
	lw                  a0,4(fp)
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	li                  a0, 2
	Minus()
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	jal                 fiboEnter
	Plus()
	b                   label3
label1:
	lw                  a0,4(fp)
label3:
	lw                  ra, 4(sp)
	addi        sp, sp, 12
	lw                  fp, 0(sp)
	jr                  ra
```
Execution Result:
```
NORMAL_TERMINATION
55
```

### 3. 
```
unit doLoop (int i, int a) {
    while (i <= 100) do {
      a := (a + i);
      i := (i + 1) } }

int main() {
  doLoop(0, 5);
  1337 }
```
S-Expression Equivalent (Post Semantic Analysis):
```
[
  [FunDecl,
    Idfr("main"),
    IntType,
    [],
    [
      [FunInvoc,
        Idfr("doLoop"),
        [IntLit(0), IntLit(5)]
      ],
      IntLit(1337)]
  ],
  [FunDecl,
    Idfr("doLoop"),
    UnitType,
    [
      [Idfr("i"), IntType],
      [Idfr("a"), IntType]
    ],
    [
      [WhileLoop,
        [BinOpExpr,
          LessEq,
          Idfr("i"),
          IntLit(100)],
        [
          [Asgmt,
            Idfr("a"),
            [BinOpExpr,
              Plus,
              Idfr("a"),
              Idfr("i")]
          ],
          [Asgmt,
            Idfr("i"),
            [BinOpExpr,
              Plus,
              Idfr("i"),
              IntLit(1)]
          ]
        ]
      ]
    ]
  ]
]
                
```
Generated RISC-V Assembly Code:
```
.text

mainEnter:
	mv                  fp, sp
	sw                  ra, 0(sp)
	addi        sp, sp, -4
	sw                  fp, 0(sp)
	addi        sp, sp, -4
	li                  a0, 5
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	li                  a0, 0
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	jal                 doLoopEnter
	li                  a0, 1337
	FinalExit()
doLoopEnter:
	mv                  fp, sp
	sw                  ra, 0(sp)
	addi        sp, sp, -4
label1:
	lw                  a0,4(fp)
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	li                  a0, 100
	CompLe()
	beq                 t2, x0, label2
	lw                  a0,8(fp)
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	lw                  a0,4(fp)
	Plus()
	sw                  a0, 8(fp)
	lw                  a0,4(fp)
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	li                  a0, 1
	Plus()
	sw                  a0, 4(fp)
	b                   label1
label2:
	lw                  ra, 4(sp)
	addi        sp, sp, 16
	lw                  fp, 0(sp)
	jr                  ra
```
Execution Result:
```
NORMAL_TERMINATION
1337
```

### 4. 
```
int main() { fact(10) }

int fact(int n) {
  if (n == 0)
  then { 1 } 
  else { (n * fact((n - 1))) } }
```
S-Expression Equivalent (Post Semantic Analysis):
```
[
  [FunDecl,
    Idfr("main"),
    IntType,
    [],
    [
      [FunInvoc,
        Idfr("fact"),
        [IntLit(10)]
      ]
    ]
  ],
  [FunDecl,
    Idfr("fact"),
    IntType,
    [
      [Idfr("n"), IntType]
    ],
    [
      [IfStmt,
        [BinOpExpr,
          Eq,
          Idfr("n"),
          IntLit(0)],
        [IntLit(1)],
        [
          [BinOpExpr,
            Times,
            Idfr("n"),
            [FunInvoc,
              Idfr("fact"),
              [
                [BinOpExpr,
                  Minus,
                  Idfr("n"),
                  IntLit(1)]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
]               
```
Generated RISC-V Assembly Code:
```
.text

mainEnter:
	mv                  fp, sp
	sw                  ra, 0(sp)
	addi        sp, sp, -4
	sw                  fp, 0(sp)
	addi        sp, sp, -4
	li                  a0, 10
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	jal                 factEnter
	FinalExit()
factEnter:
	mv                  fp, sp
	sw                  ra, 0(sp)
	addi        sp, sp, -4
	lw                  a0,4(fp)
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	li                  a0, 0
	CompEq()
	bne                 t2, x0, label1
label2:
	lw                  a0,4(fp)
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	sw                  fp, 0(sp)
	addi        sp, sp, -4
	lw                  a0,4(fp)
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	li                  a0, 1
	Minus()
	sw                  a0, 0(sp)
	addi        sp, sp, -4
	jal                 factEnter
	Times()
	b                   label3
label1:
	li                  a0, 1
label3:
	lw                  ra, 4(sp)
	addi        sp, sp, 12
	lw                  fp, 0(sp)
	jr                  ra
```
Execution Result:
```
NORMAL_TERMINATION
3628800
```








